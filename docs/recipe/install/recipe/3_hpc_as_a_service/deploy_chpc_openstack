
#!/bin/bash
# #   FILE: deploy_chpc_openstack
openstack service list
openstack project list
unset OS_SERVICE_TOKEN
export OS_USERNAME=admin
export OS_PASSWORD=<>
export OS_AUTH_URL=<>
export PS1='[\u@\h \W(keystone_admin)]\$ '
export OS_TENANT_NAME=admin
export OS_REGION_NAME=<>  

openstack role list | grep -i baremetal_admin
role_exists=$?
if [ "${role_exists}" -ne "0" ]; then 
    openstack role create baremetal_admin
fi
openstack role list | grep -i baremetal_observer 
role_exists=$?
if [ "${role_exists}" -ne "0" ]; then
    openstack role create baremetal_observer
fi
systemctl restart openstack-ironic-api

yum install -y tftp-server syslinux-tftpboot xinetd

mkdir -p /tftpboot
chown -R ironic /tftpboot

#Configure tftp 
#Configure /etc/xinet.d/tftp
echo "service tftp" > /etc/xinetd.d/tftp
echo "{" >> /etc/xinetd.d/tftp
echo "  protocol        = udp" >> /etc/xinetd.d/tftp
echo "  port            = 69" >> /etc/xinetd.d/tftp
echo "  socket_type     = dgram" >> /etc/xinetd.d/tftp
echo "  wait            = yes" >> /etc/xinetd.d/tftp
echo "  user            = root" >> /etc/xinetd.d/tftp
echo "  server          = /usr/sbin/in.tftpd" >> /etc/xinetd.d/tftp
echo "  server_args     = -v -v -v -v -v --map-file /tftpboot/map-file /tftpboot" >> /etc/xinetd.d/tftp
echo "  disable         = no" >> /etc/xinetd.d/tftp
echo "  (*\#*) This is a workaround for Fedora, where TFTP will listen only on" >> /etc/xinetd.d/tftp
echo "  (*\#*) IPv6 endpoint, if IPv4 flag is not used." >> /etc/xinetd.d/tftp
echo "  flags           = IPv4" >> /etc/xinetd.d/tftp
echo "}" >> /etc/xinetd.d/tftp
systemctl restart xinetd
cp /var/lib/tftpboot/pxelinux.0 /tftpboot
cp /var/lib/tftpboot/chain.c32 /tftpboot
echo 're ^(/tftpboot/) /tftpboot/\2' > /tftpboot/map-file
echo 're ^/tftpboot/ /tftpboot/' >> /tftpboot/map-file
echo 're ^(^/) /tftpboot/\1' >> /tftpboot/map-file
echo 're ^([^/]) /tftpboot/\1' >> /tftpboot/map-file

sed --in-place "s|(*\#*)tftp_server=\$my_ip|tftp_server=${controller_ip}|" /etc/ironic/ironic.conf

sed --in-place "s|(*\#*)tftp_root=/tftpboot|tftp_root=/tftpboot|" /etc/ironic/ironic.conf
sed --in-place "s|(*\#*)ip_version=4|ip_version=4|" /etc/ironic/ironic.conf
sed --in-place "s|(*\#*)automated_clean=true|automated_clean=false|" /etc/ironic/ironic.conf

sed --in-place "s|(*\#*)scheduler_use_baremetal_filters=false|scheduler_use_baremetal_filters=true|" \

sed --in-place "s|reserved_host_memory_mb=512|reserved_host_memory_mb=0|" /etc/nova/nova.conf
sed --in-place "s|(*\#*)scheduler_host_subset_size=1|scheduler_host_subset_size=9999999|" /etc/nova/nova.conf

# Enable meta data
# Edit /etc/neutron/dhcp_agent.ini
sed --in-place "s|enable_isolated_metadata\ =\ False|enable_isolated_metadata\ =\ True|" /etc/neutron/dhcp_agent.ini
sed --in-place "s|(*\#*)force_metadata\ =\ false|force_metadata\ =\ True|" \ /etc/neutron/dhcp_agent.ini

#(*\#*)(*\#*)(*\#*)(*\#*)
# Enable internal dns for hostname resolution, if it already not set
# manipulating configuration file via shell, alternate is to use openstack-config (TODO)
#(*\#*)(*\#*)(*\#*)
# setup dns domain first
if grep -q "^dns_domain.*openstacklocal$" /etc/neutron/neutron.conf; then
   sed -in-place  "s|^dns_domain.*|dns_domain = oslocal|" /etc/neutron/neutron.conf
else
   if ! grep -q "^dns_domain" neutron.conf; then
       sed -in-place  "s|^(*\#*)dns_domain = openstacklocal$|dns_domain = oslocal|" /etc/neutron/neutron.conf
   fi
fi
# configure ml2 dns driver for neutron
ml2file=/etc/neutron/plugins/ml2/ml2_conf.ini
if ! grep -q "^extension_drivers" $ml2file; then
    (*\#*) Assuming there is a place holder in comments, replace that string
    sed -in-place  "s|^(*\#*)extension_drivers.*|extension_drivers = port_security,dns|" $ml2file
else
    (*\#*) Entry is present, check if dns is already present, if not then enable
    if ! grep "^extension_drivers" $ml2file|grep -q dns; then
        current_dns=`grep "^extension_drivers" $ml2file`
        new_dns="$current_dns,dns"
        sed -in-place  "s|^extension_drivers.*|$new_dns|" $ml2file
    fi
fi

systemctl restart neutron-dhcp-agent
systemctl restart neutron-openvswitch-agent
systemctl restart neutron-metadata-agent
systemctl restart neutron-server
systemctl restart openstack-nova-scheduler
systemctl restart openstack-nova-compute
systemctl restart openstack-ironic-conductor

function setup_baremetal() {
#Get the tenant ID for the services tenant
#Create the flat network on which you are going to launch instances
    neutron net-list | grep "|\s*sharednet1\s*|"
    net_exists=$?
    if [ "${net_exists}" -ne "0" ]; then
        neutron net-create --tenant-id ${SERVICES_TENANT_ID} sharednet1 --shared --provider:network_type flat --provider:physical_network physnet1
    fi
    NEUTRON_NETWORK_UUID=`neutron net-list | grep "|\s*sharednet1\s*|" | awk '{print $2}'`

#Create the subnet on the newly created network
    neutron subnet-list | grep "|\s*subnet01\s*|"
    subnet_exists=$?
    if [ "${subnet_exists}" -ne "0" ]; then
        neutron subnet-create sharednet1 --name subnet01 --ip-version=4 --gateway=${controller_ip} --allocation-pool start=${cc_subnet_dhcp_start},end=${cc_subnet_dhcp_end} --enable-dhcp ${cc_subnet_cidr}
    fi
    NEUTRON_SUBNET_UUID=`neutron subnet-list | grep "|\s*subnet01\s*|" | [ctrlr](*\#*) awk '{print $2}'`

#Create the deploy-kernel and deploy-initrd images
    glance image-list | grep "|\s*deploy-vmlinuz\s*|"
    img_exists=$?
    if [ "${img_exists}" -ne "0" ]; then
        glance image-create --name deploy-vmlinuz --visibility public --disk-format aki --container-format aki < ${chpc_image_deploy_kernel}
    fi
    DEPLOY_VMLINUZ_UUID=`glance image-list | grep "|\s*deploy-vmlinuz\s*|" | awk '{print $2}'`
    glance image-list | grep "|\s*deploy-initrd\s*|"
    img_exists=$?
    if [ "${img_exists}" -ne "0" ]; then
        glance image-create --name deploy-initrd --visibility public --disk-format ari --container-format ari < ${chpc_image_deploy_ramdisk}
    fi
    DEPLOY_INITRD_UUID=`glance image-list | grep "|\s*deploy-initrd\s*|" | awk '{print $2}

#Create the baremetal flavor and set the architecture to x86_64
# This will create common baremetal flavor, if SMS node & compute has different
# characteristic than user shall create multiple flavor one each characterisitc
    nova flavor-list | grep "|\s*baremetal-flavor\s*|"
    flavor_exists=$?
    if [ "$flavor_exists" -ne "0" ]; then
        nova flavor-create baremetal-flavor baremetal-flavor ${RAM_MB} ${DISK_GB} ${CPU}
        nova flavor-key baremetal-flavor set cpu_arch=$ARCH
    fi
    FLAVOR_UUID=`nova flavor-list | grep "|\s*baremetal-flavor\s*|" | awk '{print $2}'`
#Increase the Quota limit for admin to allow nova boot
    openstack quota set --ram 512000 --cores 1000 --instances 100 admin

#Register SSH keys with Nova
 nova keypair-list | grep "|\s*ostack_key\s*|"
 keypair_exists=$?
 if [ "${keypair_exists}" -ne "0" ]; then
    nova keypair-add --pub-key ${HOME}/.ssh/id_rsa.pub ostack_key
 fi

    KEYPAIR_NAME=ostack_key
}

function setup_sms() {
# Create sms node image
   glance image-list | grep "|\s*sms-image\s*|"
   img_exists=$?
   if [ "${img_exists}" -ne "0" ]; then
       glance image-create --name sms-image --visibility public --disk-format qcow2 --container-format bare < ${chpc_image_sms}
   fi
   SMS_DISK_IMAGE_UUID=`glance image-list | grep "|\s*sms-image\s*|" | awk '{print $2}'`

#Create a sms node in the bare metal service ironic.
    ironic node-list | grep "|\s*${sms_name}$\s*|"
    node_exists=$?
    if [ "${node_exists}" -ne "0" ]; then 
        ironic node-create -d pxe_ipmitool -i deploy_kernel=${DEPLOY_VMLINUZ_UUID} -i deploy_ramdisk=${DEPLOY_INITRD_UUID} -i ipmi_terminal_port=8023 -i ipmi_address=${sms_bmc} -i ipmi_username=${sms_bmc_username} -i ipmi_password=${sms_bmc_password} -p cpus=${CPU} -p memory_mb=${RAM_MB} -p local_gb=${DISK_GB} -p cpu_arch=${ARCH} -p capabilities="boot_mode:bios" -n ${sms_name}
    fi

#Add the associated port(s) MAC address to the created node(s)
    ironic port-create -n ${SMS_UUID} -a ${sms_mac}

    ironic node-update $SMS_UUID add instance_info/image_source=${SMS_DISK_IMAGE_UUID} instance_info/root_gb=50

#Setup neutron port for static IP addressing of sms node, this is an optional part
neutron port-create sharednet1 --dns_name $sms_name --fixed-ip ip_address=$sms_ip --name $sms_name --mac-address $sms_mac
    SMS_PORT_ID=`neutron port-list | grep "|\s*$sms_name\s*|" | awk '{print $2}'`
}

function setup_cn() {
#Create the whole-disk-image from the user's qcow2 file
    glance image-list | grep "|\s*user-image\s*|"
    img_exists=$?
    if [ "${img_exists}" -ne "0" ]; then
        glance image-create --name user-image --visibility public --disk-format qcow2 --container-format bare < ${chpc_image_user}
    fi
    USER_DISK_IMAGE_UUID=`glance image-list | grep "|\s*user-image\s*|" | awk '{print $2}'`

# Setup Compute nodes
# Note: if installed from the rpm, the following script is installed as setup_compute_nodes.sh 
    for ((i=0; i < ${num_ccomputes}; i++)); do
        (*\#*)(*\#*)Create compute nodes in the bare metal service
        ironic node-list | grep "|\s*${cnodename_prefix}$((i+1))\s*|"
        node_exists=$?
        if [ "${node_exists}" -ne "0" ]; then
            ironic node-create -d pxe_ipmitool -i deploy_kernel=${DEPLOY_VMLINUZ_UUID} -i deploy_ramdisk=${DEPLOY_INITRD_UUID} -i ipmi_terminal_port=8023 -i ipmi_address=${cc_bmc[$i]} -i ipmi_username=${cc_bmc_username} -i ipmi_password=${cc_bmc_password} -p cpus=${CPU} -p memory_mb=${RAM_MB} -p local_gb=${DISK_GB} -p cpu_arch=${ARCH} -p capabilities="boot_mode:bios" -n ${cnodename_prefix}$((i+1))
       fi
       NODE_UUID_CC[$i]=`ironic node-list | grep "|\s*${cnodename_prefix}$((i+1))\s*|" | awk '{print $2}'`
        (*\#*) update for compute nodes node MAC
        ironic port-create -n ${NODE_UUID_CC[$i]} -a ${cc_mac[$i]}
        (*\#*)Add the instance_info/image_source and instance_info/root_gb
        ironic node-update ${NODE_UUID_CC[$i]} add instance_info/image_source=${USER_DISK_IMAGE_UUID} instance_info/root_gb=50
        (*\#*)Setup neutron port for static IP addressing of compute nodes
        cn_name=${cnodename_prefix}$((i+1))
        neutron port-create sharednet1 --dns_name $cn_name --fixed-ip ip_address=${cc_ip[$i]} --name $cn_name --mac-address ${cc_mac[$i]}
        NEUTRON_PORT_ID_CC[$i]=`neutron port-list | grep "|\s*${cnodename_prefix}$((i+1))\s*|" | awk '{print $2}'`
    Done

# Wait for the Nova hypervisor-stats to sync with available Ironic resources
sleep 121
}

function boot_sms() {
#Boot the sms node with nova. chpcInit is set from prepare_cloudInit
echo "nova boot --config-drive true --flavor ${FLAVOR_UUID} --image ${SMS_DISK_IMAGE_UUID} --key-name ${KEYPAIR_NAME} --meta role=webservers --user-data=$chpcSMSInit --nic port-id=${SMS_PORT_ID} ${sms_name}" > boot_sms

nova boot --config-drive true --flavor ${FLAVOR_UUID} --image ${SMS_DISK_IMAGE_UUID} --key-name ${KEYPAIR_NAME} --meta role=webservers --user-data=$chpcSMSInit --nic port-id=${SMS_PORT_ID} ${sms_name}

sleep 15
}

function boot_cn() {
for ((i=0; i < ${num_ccomputes}; i++)); do
filename="cn$((i+1))"
echo "nova boot --config-drive true --flavor ${FLAVOR_UUID} --image ${USER_DISK_IMAGE_UUID} --key-name ${KEYPAIR_NAME} --meta role=webservers --user-data=$chpcInit --nic port-id=${NEUTRON_PORT_ID_CC[$i]} ${cnodename_prefix}$((i+1))" > boot_$filename
nova boot --config-drive true --flavor ${FLAVOR_UUID} --image ${USER_DISK_IMAGE_UUID} --key-name ${KEYPAIR_NAME} --meta role=webservers --user-data=$chpcInit --nic port-id=${NEUTRON_PORT_ID_CC[$i]} ${cnodename_prefix}$((i+1))
#wait for 5 sec before booting other compute node
sleep 5
done
}
# ## Initial setup baremetal environment 
setup_baremetal
# ## Setup SMS node first
setup_sms
# ## Setup Compute nodes second
setup_cn
# ## Wait for the Nova hypervisor-stats to sync with available Ironic resources
sleep 121
# ## Boot sms node
boot_sms
# ## # wait for 15 sec before starting to boot compute nodes. TBD need to tune this time
# ## # SMS node should be booted before compute nodes starts booting. At minimum
# ## # sms node shall have cloud init executed before CN's cloud init
sleep 15
# ## # Now boot compute nodes
boot_cn
#   
