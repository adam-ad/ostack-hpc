#!../common/bats/bin/bats
# -*-sh-*-

load ../common/test_helper_functions || exit 1

if [ -s ../TEST_ENV ];then
    source ../TEST_ENV
fi

testname=CLCK
PKG=CLCK
module=clck
rpm=intel-clck${DELIM}

setup() {
    if [ -z "$MODULEPATH" ];then
	. /etc/profile.d/lmod.sh || exit 1
    fi
    module purge        || exit 1
    module load $module || exit 1
    # define shared temp_dir
    export CLCK_SHARED_TEMP_DIR=`pwd`
}

containsElement () {
  local e
  for e in "${@:2}"; do [[ "$e" =~ "$1" ]] && return 0; done
  return 1
}

@test "[$testname] Verify $PKG module is loaded and matches rpm version" {

    test -n "$CLCK_ROOT"

    which clck

    # query module version
    module list $module | grep "1) $module" >& .cmd_output || exit 1
    grep $module .cmd_output 

    # check version against rpm
    local version="$(rpm -q --queryformat='%{VERSION}\n' $rpm)"
    run cat .cmd_output
    assert_output "  1) $module/$version"

    # check version against binary

    clck --version | head -1 | awk '{print $4}' >& .cmd_output || exit 1
    run cat .cmd_output
    assert_output "$version"
    
}

@test "[CLCK] create clck nodelist" {
    rm -f clck.nodelist
    # ssh from HN to HN isn't enabled currently
#    echo `hostname -s`" # role: head" >> clck.nodelist
#    echo "localhost  # role: head" >> clck.nodelist
    # the clck module prepends their path -- which include a non-orch pdsh
    /usr/bin/pdsh -g compute uptime | grep average | awk '{print $1}' | sed 's/://' >> clck.nodelist
    num_hosts=`wc -l clck.nodelist | awk '{print $1}'`
    if [ "$num_hosts" -lt 2 ];then
	ERROR_RETURN "Test requires at least 2 hosts"
    fi
}

@test "[CLCK] verify environment consistent on valid cluster nodes" {
    rm -f ~/.clck/*/clck.db 
    cat clck.nodelist
    clck-collect -l debug -s environment -f clck.nodelist
    clck-analyze -g -l debug -I environment -f clck.nodelist
}

@test "[CLCK] verify rpms consistent" {
    cat clck.nodelist
    run clck-analyze -g -v -l debug -I rpm -f clck.nodelist
    printf '%s\n' "${lines[@]}"
    containsElement "FAIL" "${lines[@]}"

    clck-collect -l debug -s rpm -f clck.nodelist
    clck-analyze -g -l debug -I rpm -f clck.nodelist
}

@test "[CLCK] verify ethernet driver uniformity" {
    cat clck.nodelist
    run clck-analyze -g -l debug -I ethernet -f clck.nodelist
    printf '%s\n' "${lines[@]}"
    containsElement "FAIL" "${lines[@]}"

    clck-collect -l debug -s ethernet -f clck.nodelist
    clck-analyze -g -l debug -I ethernet -f clck.nodelist
}

@test "[CLCK] verify cpu" {
    cat clck.nodelist
    run clck-analyze -g -l debug -I cpu -f clck.nodelist
    printf '%s\n' "${lines[@]}"
    containsElement "FAIL" "${lines[@]}"

    clck-collect -l debug -s cpu -f clck.nodelist
    clck-analyze -g -l debug -I cpu -f clck.nodelist
}

@test "[CLCK] verify ntp clock synchronization" {
    run clck-analyze -g -l debug -I ntp -f clck.nodelist
    printf '%s\n' "${lines[@]}"
    containsElement "FAIL" "${lines[@]}"

    clck-collect -l debug -s ntp -f clck.nodelist
    clck-analyze -g -l debug -I ntp -f clck.nodelist
}

@test "[CLCK] verify error detected when invalid nodename prescribed" {
    cp -p clck.nodelist clck.nodelist.invalid

    echo "bad-nodename" >> clck.nodelist.invalid
    run clck-collect -l debug -m printenv -f clck.nodelist.invalid
    printf '%s\n' "${lines[@]}"
    assert_failure
    run clck-analyze -g -l debug -I environment -f clck.nodelist.invalid
    printf '%s\n' "${lines[@]}"
    containsElement "FAIL" "${lines[@]}"
}

rm -f .cmd_output
